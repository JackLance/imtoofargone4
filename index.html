<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="description" content="A game made with the PuzzleScript game engine.">
<title>PuzzleScript Game</title>
<style>

body {
	background-color:black;
	font-family:"Courier New", Courier, monospace;
    touch-action: none;
}
#gameCanvas {
  position:absolute;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  bottom: 0px;
  right:0px;
  border: 0px;
  background-color: black;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  image-rendering: -moz-crisp-edges;
  image-rendering: -webkit-crisp-edges;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
} 

.homepagelink {
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 50%;
}

h1 {
	color:lightblue;
	font-weight:normal;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    height:2em;
    margin-top:0.5em;
    margin-bottom: 0.5em;
}
a {
	color:lightblue;
}
.title {	
	background-color:none;
	text-align:center;
	font-size:100%;
	float:center;
	color:gray;
	position:absolute;
	left:10%;
	right:10%;
	top:0%;
	height:3em;
}

.footer {	
	background-color:none;
	text-align:center;
	float:center;
	color:white;
	position:absolute;
	left:0%;
	right:0%;
	height:3em;
	bottom:0;
}
.gameContainer {
	background-color:none;
	position:absolute;
	left:0%;
	right:0%;
	top:3.5em;
	bottom:3em;
  touch-action: none;
}

      .mobile-menu {
          position: relative;
          top: 5em;
          margin-left: auto;
          margin-right: auto;
          font-weight: bold;
          border-radius: 0.25em;
      }

      .mobile-menu.item-count-3 {
          width: 30em;
      }
      .mobile-menu.item-count-3 .button {
          width: 28.3333%;
          /* scale the height of the button relative to the width of .mobile-menu */
          padding: 7.5% 0%;
      }

      .mobile-menu.item-count-2 {
          width: 20em;
      }
      .mobile-menu.item-count-2 .button {
          width: 46%;
          /* scale the height of the button relative to the width of .mobile-menu */
          padding: 12.1765% 0%;
      }

      .mobile-menu.item-count-1 {
          width: 10em;
      }
      .mobile-menu.item-count-1 .button {
          width: 98%;
          /* scale the height of the button relative to the width of .mobile-menu */
          padding: 26.5% 0%;
      }

      .mobile-menu,
      .tab-icon,
      .mobile-menu .close {
          background: rgba(0,0,0,0.4);
          border: 2px solid rgba(255, 255, 255, 0.4);
          color: rgba(255, 255, 255, 1);
      }

      .mobile-menu .button {
          margin: 2%;
          border-radius: 0.25em;
          text-align: center;
          float: left;
      }
      .mobile-menu .clear {
          clear: both;
      }

      .tab-affordance,
      .close-affordance {
          width: 6em;
          height: 6em;
          position: absolute;
          z-index: 1000;
      }

      .tab-affordance {
          left: -2em;
          top: 5em;
      }

      .close-affordance {
          left: -4em;
          top: -1em;
      }

      .tab-icon,
      .mobile-menu .close {
          height: 48px;
          position: absolute;
          border-radius: 6px;
      }

      .tab-icon {
          left: -0.5em;
          top: 70px;
          width: 18px;
          border-radius: 0 6px 6px 0;
          border-left: 0;
      }

      .mobile-menu .close {
          left: -18px;
          width: 18px;
          top: 0px;
          border-radius: 6px 0 0 6px;
          border-right: 0;
      }

      .tab-icon .slice,
      .mobile-menu .close .slice {
          margin: 4.5px 1px;
          width: 2px;
          height: 80%;
          background: rgba(255, 255, 255, 0.4);
      }

      .tab-icon .slice {
          float: right;
      }

      .tab-icon .slice:first-child {
           margin-right: 4.5px;
      }

      .mobile-menu .close .slice {
          float: left;
      }
      .mobile-menu .close .slice:first-child {
           margin-left: 4.5px;
      }

      @media screen and (max-width: 32em) {
          .mobile-menu {
              font-size: 0.8em;
              width: 90%;
          }
      }
      @media screen and (max-width: 24em) {
          .mobile-menu {
              font-size: 0.65em;
              width: 90%;
          }
      }

     .disable-select {
         -webkit-touch-callout: none;
         -webkit-user-select: none;
         -khtml-user-select: none;
         -moz-user-select: none;
         -ms-user-select: none;
         user-select: none;
     }

a {
    display:inline-block;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 80%;
}
</style>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
</head>
<body>
<div class="title"><h1 id="gametitle">PuzzleScript Game</h1></div>
<div class="gameContainer">
<canvas 
    id="gameCanvas" ></canvas>
</div> 
<div class="footer">
<span id="errormessage" style="color:red;"></span>
<a id="homepagelink" href="https://www.puzzlescript.net" target="_blank">www.puzzlescript.net</a> <span id="separator">|</span> <a id="hacklink" href="#">hack</a>
</div>

<!--___SCRIPTINSERT___-->
<script src="src/js/storagewrapper.js"></script>
<script src="src/js/globalVariables.js"></script>
<script src="src/js/debug_off.js"></script>
<script src="src/js/font.js"></script>
<script src="src/js/rng.js"></script>
<script src="src/js/riffwave.js"></script>
<script src="src/js/sfxr.js"></script>
<script src="src/js/codemirror/stringstream.js"></script>
<script src="src/js/colors.js"></script>
<script src="src/js/graphics.js"></script>
<script src="src/js/engine.js"></script>
<script src="src/js/parser.js"></script>
<script src="src/js/compiler.js"></script>
<script src="src/js/inputoutput.js"></script>
<script src="src/js/mobile.js"></script>

<script>


	var githubURL = 'https://api.github.com/gists/50c5dea44a8b5d738d4c2542ff5f08d0'

	var githubHTTPClient = new XMLHttpRequest();
	githubHTTPClient.open('GET', githubURL);
	githubHTTPClient.onreadystatechange = function() {
		if(githubHTTPClient.readyState!=4) {
			return;
		}		
		var result = JSON.parse(githubHTTPClient.responseText);
		if (githubHTTPClient.status===403) {
			displayError(result.message);
		} else if (githubHTTPClient.status!==200&&githubHTTPClient.status!==201) {
			displayError("HTTP Error "+ githubHTTPClient.status + ' - ' + githubHTTPClient.statusText);
		}
		var result = JSON.parse(githubHTTPClient.responseText);
		var code=result["files"]["script.txt"]["content"];
		compile(["restart"],code);

		if (state.metadata.homepage!==undefined) {
			var homepage=state.metadata.homepage;
			var homepageLink = document.getElementById("homepagelink");
          
                homepageLink.textContent=strip_http(homepage);
            
			
 			if (!homepage.match(/^https?:\/\//)) {
 				homepage = "https://" + homepage;
 			}
 			homepageLink.href = homepage;
		}
		if (state.metadata.title!==undefined) {
			var title=state.metadata.title;
			var gametitle = document.getElementById("gametitle");
            gametitle.textContent=title;
			window.document.title=title+" - PuzzleScript Game";
		}
                
		var hacklink = document.getElementById("hacklink");


		hacklink.onclick=hackclicked;
        
	}
    // if (storage_has('oauth_access_token')) {
    //     var oauthAccessToken = storage_get("oauth_access_token");
    //     if (typeof oauthAccessToken === "string") {
    //         githubHTTPClient.setRequestHeader("Authorization","token "+oauthAccessToken);
    //     }
    // }
	githubHTTPClient.setRequestHeader("Content-type","application/x-www-form-urlencoded");
	githubHTTPClient.send();


grid = {};
player = {type: "player", pos: [7, 7, 0]}
thing = {type: "thing", pos: [5, 5, 0]};

for(var i=0; i<11; i++) for(var j=0; j<11; j++) grid[[i, j, 1]] = {type: "floor", pos:[i, j, 1]}

grid[player.pos] = player;
grid[thing.pos] = thing;

canvas = document.getElementById ('gameCanvas' );
ctx = canvas.getContext ('2d' );
  cellsize = Math.floor(Math.min(canvas.height / 105, canvas.width /  105))* 5;
hpad = canvas.height - 21*cellsize;
wpad = canvas.width - 21*cellsize;
mysprites = {
  player: '.....|.aaa.|.aaa.|.aaa.|.....',
  thing: 'bbbbb|bbbbb|bbbbb|bbbbb|bbbbb',
  alertr: '....c|....c|....c|....c|....c',
  alertu: 'ccccc|.....|.....|.....|.....',
  alertd: '.....|.....|.....|.....|ccccc',
  alertl: 'c....|c....|c....|c....|c....',
  ground: 'ddddd|ddddd|ddddd|ddddd|ddddd'
};
cols = {
  a: '#F7E26B',
  b: '#E0E0E0',
  c: '#FFDD00',
  d: '#707070',
  
};

timeoutId = -1;
goalpost = 12;
movegoalpost = [];

colors = {"thing":"#664444", "player":"pink", "red": "red", "green": "green", "blue": "blue", "yellow": "yellow"};
cols = ["red", "green", "blue", "yellow"]
normal = {"red": "#dd2020", "green": "#20dd20", "yellow": "#eeee20", "blue":"#5050ff"}
darker = {"red": "#992020", "green": "#209920", "yellow": "#bbbb20", "blue":"#3030aa"}
darkest = {"red": "#662020", "green": "#206620", "yellow": "#888820", "blue":"#202077"}
darkestest = {"red": "#332020", "green": "#203320", "yellow": "#444420", "blue":"#202033"}
undostack = []

messages = ["Hi, it's Jack. Just so you know, you can press X to use the generator.",
"Hi again, it's me. If you want, you can press [ to slow down, and ] to speed up the game's clock. This is also just for convenience and has no effect on the puzzle.",
"Hey there, if you press K and a number key, I'll [k]eep your state saved. Then press L and that same number key, and I'll [l]oad your state. This is just for convenience and has no effect on the puzzle.",
"Oh, hey. I didn't think you'd click that. This is actually not a puzzlescript game at all. I just made it look like this because it's a sequel to a puzzlescript game.",
"Hello, it's me. I guess I wasn't clear about this, but the goal is to get the *player* past the finish line.",
"You too have gone far! :D",
"Um... hey. The finish line is currently 10000 units away from the platform. You should probably rethink your approach. (If you beat this game by overloading my javascript numbers or whatever that doesn't count as a win.)"]
messagesaid = [false, false, false, false, false, false, false]
xpressed = false;
connecteds = [1, 1, 1, 1];
savestate();

function hackclicked(){
  if(!messagesaid[3]){
  messagetext = messages[3];
      showTempMessage() 
      messagesaid[3] = true;
    }
}

function rect(a, b, c, d){
  ctx.fillRect(a - camerax, b - cameray, c, d);
}
stopdrawing = false;
showmessage5 = false;
function draw(){
  if(stopdrawing) return;
  if(textMode) return;
  cellsize = Math.floor(Math.min(canvas.height / 105, canvas.width /  135))* 5;
hpad = canvas.height - 21*cellsize;
wpad = canvas.width - 27*cellsize;

    camerax = player.pos[1]*cellsize - Math.floor(canvas.width/2);
    cameray = player.pos[0]*cellsize - Math.floor(canvas.height/2);
    
    ctx.fillStyle = "#101010";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    
    ctx.fillStyle = "#F0F0F0";
    rect(0, 0, cellsize*11, cellsize*11);
   for(var z=2; z>=0; z--){
      Object.values(grid).map((object) => {
        if(object.pos[2] != z) return;
        if(object == player){
        
          ctx.fillStyle = ["#4BC2D7", "#2B6277", "#1B3247"][object.pos[2]];
          rect(object.pos[1]*cellsize + cellsize/5, object.pos[0]*cellsize + cellsize/5, cellsize*3/5, cellsize*3/5);
        }
        if(object == thing){
          ctx.fillStyle = "#D0D0D0";
          rect(object.pos[1]*cellsize , object.pos[0]*cellsize , cellsize, cellsize);
        }
        if(object.type == "red" || object.type == "blue" || object.type == "yellow" || object.type == "green"){
          if(!messagesaid[4] && object.pos[1] > goalpost && goalpost > player.pos[1] + 40){
            showmessage5 = true;
              
            }

          if(object.pos[2] == 2){
             ctx.fillStyle = darkest[object.type];
             //rect(object.pos[1]*cellsize, object.pos[0]*cellsize, cellsize, cellsize);
             //ctx.fillStyle = darkest[object.type];
             rect(object.pos[1]*cellsize + cellsize/5, object.pos[0]*cellsize + cellsize/5, cellsize*3/5, cellsize*3/5);
             return;
          }
          if(object.pos[2] == 1){
            ctx.fillStyle = darkest[object.type];
            rect(object.pos[1]*cellsize, object.pos[0]*cellsize, cellsize, cellsize);
            ctx.fillStyle = darker[object.type];
            rect(object.pos[1]*cellsize + cellsize/5, object.pos[0]*cellsize + cellsize/5, cellsize*3/5, cellsize*3/5);

             touches = [false, false, false, false]
            for(var d=0; d<4; d++){
              if(grid[add(object.pos, dirs[d])] && grid[add(object.pos, dirs[d])].type == object.type){
                ctx.fillStyle = darker[object.type];
                touches[d] = true;
              }else{
                ctx.fillStyle = darkest[object.type];
              }
              if(d == 0) rect(object.pos[1]*cellsize + cellsize/5, object.pos[0]*cellsize, cellsize*3/5, cellsize*1/5);
              if(d == 1) rect(object.pos[1]*cellsize , object.pos[0]*cellsize+ cellsize/5, cellsize*1/5, cellsize*3/5);
              if(d == 2) rect(object.pos[1]*cellsize + cellsize/5, object.pos[0]*cellsize + 4*cellsize/5, cellsize*3/5, cellsize*1/5);
              if(d == 3) rect(object.pos[1]*cellsize + 4*cellsize/5, object.pos[0]*cellsize+ cellsize/5, cellsize*1/5, cellsize*3/5);
            }
            ctx.fillStyle = darker[object.type];
            if(touches[0] && touches[1]) rect(object.pos[1]*cellsize , object.pos[0]*cellsize, cellsize/5, cellsize/5);
            if(touches[2] && touches[1]) rect(object.pos[1]*cellsize , object.pos[0]*cellsize+ 4*cellsize/5, cellsize/5, cellsize/5);
            if(touches[2] && touches[3]) rect(object.pos[1]*cellsize + 4*cellsize/5, object.pos[0]*cellsize+ 4*cellsize/5, cellsize/5, cellsize/5);
            if(touches[0] && touches[3]) rect(object.pos[1]*cellsize + 4*cellsize/5, object.pos[0]*cellsize, cellsize/5, cellsize/5);
            ctx.fillStyle = darkest[object.type];
            if(touches[0] != touches[1]) rect(object.pos[1]*cellsize , object.pos[0]*cellsize, cellsize/5, cellsize/5);
            if(touches[2] != touches[1]) rect(object.pos[1]*cellsize , object.pos[0]*cellsize+ 4*cellsize/5, cellsize/5, cellsize/5);
            if(touches[2] != touches[3]) rect(object.pos[1]*cellsize + 4*cellsize/5, object.pos[0]*cellsize+ 4*cellsize/5, cellsize/5, cellsize/5);
            if(touches[0] != touches[3]) rect(object.pos[1]*cellsize + 4*cellsize/5, object.pos[0]*cellsize, cellsize/5, cellsize/5);


            return;
          }
          
          
          ctx.fillStyle = normal[object.type];
          rect(object.pos[1]*cellsize + cellsize/5, object.pos[0]*cellsize + cellsize/5, cellsize*3/5, cellsize*3/5);

          touches = [false, false, false, false]
          for(var d=0; d<4; d++){
            if(grid[add(object.pos, dirs[d])] && grid[add(object.pos, dirs[d])].type == object.type){
              ctx.fillStyle = normal[object.type];
              touches[d] = true;
            }else{
              ctx.fillStyle = darker[object.type];
            }
            if(d == 0) rect(object.pos[1]*cellsize + cellsize/5, object.pos[0]*cellsize, cellsize*3/5, cellsize*1/5);
            if(d == 1) rect(object.pos[1]*cellsize , object.pos[0]*cellsize+ cellsize/5, cellsize*1/5, cellsize*3/5);
            if(d == 2) rect(object.pos[1]*cellsize + cellsize/5, object.pos[0]*cellsize + 4*cellsize/5, cellsize*3/5, cellsize*1/5);
            if(d == 3) rect(object.pos[1]*cellsize + 4*cellsize/5, object.pos[0]*cellsize+ cellsize/5, cellsize*1/5, cellsize*3/5);
          }
          ctx.fillStyle = normal[object.type];
          if(touches[0] && touches[1]) rect(object.pos[1]*cellsize , object.pos[0]*cellsize, cellsize/5, cellsize/5);
          if(touches[2] && touches[1]) rect(object.pos[1]*cellsize , object.pos[0]*cellsize+ 4*cellsize/5, cellsize/5, cellsize/5);
          if(touches[2] && touches[3]) rect(object.pos[1]*cellsize + 4*cellsize/5, object.pos[0]*cellsize+ 4*cellsize/5, cellsize/5, cellsize/5);
          if(touches[0] && touches[3]) rect(object.pos[1]*cellsize + 4*cellsize/5, object.pos[0]*cellsize, cellsize/5, cellsize/5);
          ctx.fillStyle = darker[object.type];
          if(touches[0] != touches[1]) rect(object.pos[1]*cellsize , object.pos[0]*cellsize, cellsize/5, cellsize/5);
          if(touches[2] != touches[1]) rect(object.pos[1]*cellsize , object.pos[0]*cellsize+ 4*cellsize/5, cellsize/5, cellsize/5);
          if(touches[2] != touches[3]) rect(object.pos[1]*cellsize + 4*cellsize/5, object.pos[0]*cellsize+ 4*cellsize/5, cellsize/5, cellsize/5);
          if(touches[0] != touches[3]) rect(object.pos[1]*cellsize + 4*cellsize/5, object.pos[0]*cellsize, cellsize/5, cellsize/5);

           for(var d=0; d<4; d++){
            if(equals(object.pos, add(thing.pos, dirs[d]))){
              if(!connecteds[d]){
                ctx.fillStyle = darker[object.type];
                 if(d == 2) rect(object.pos[1]*cellsize , object.pos[0]*cellsize, cellsize*5/5, cellsize*1/5);
                if(d == 3) rect(object.pos[1]*cellsize , object.pos[0]*cellsize, cellsize*1/5, cellsize*5/5);
                if(d == 0) rect(object.pos[1]*cellsize , object.pos[0]*cellsize + 4*cellsize/5, cellsize*5/5, cellsize*1/5);
                if(d == 1) rect(object.pos[1]*cellsize + 4*cellsize/5, object.pos[0]*cellsize, cellsize*1/5, cellsize*5/5);
                ctx.fillStyle = normal[object.type];
                if(d == 2) rect(object.pos[1]*cellsize + cellsize/5, object.pos[0]*cellsize, cellsize*3/5, cellsize*1/5);
            if(d == 3) rect(object.pos[1]*cellsize , object.pos[0]*cellsize+ cellsize/5, cellsize*1/5, cellsize*3/5);
            if(d == 0) rect(object.pos[1]*cellsize + cellsize/5, object.pos[0]*cellsize + 4*cellsize/5, cellsize*3/5, cellsize*1/5);
            if(d == 1) rect(object.pos[1]*cellsize + 4*cellsize/5, object.pos[0]*cellsize+ cellsize/5, cellsize*1/5, cellsize*3/5);
              }
            }
           }
        }
        //ctx.fillStyle = colors[object.type];
        //ctx.fillRect(object.pos[1]*cellsize, object.pos[0]*cellsize, cellsize-1-5*object.pos[2], cellsize-1-5*object.pos[2]);
        
      })
    
    ctx.fillStyle = "#F7E26B";
    if(connecteds[0]){    
      rect(thing.pos[1]*cellsize , thing.pos[0]*cellsize , cellsize, cellsize/5);
    }
    if(connecteds[1]){
      rect(thing.pos[1]*cellsize , thing.pos[0]*cellsize , cellsize/5, cellsize);
    }
    if(connecteds[2]){
      rect(thing.pos[1]*cellsize, thing.pos[0]*cellsize  +cellsize*4/5, cellsize, cellsize/5);
    }
    if(connecteds[3]){
      rect(thing.pos[1]*cellsize  +cellsize*4/5, thing.pos[0]*cellsize , cellsize/5, cellsize);
    }
    if((connecteds[0] || connecteds[1] || connecteds[2] || connecteds[3]) && (counter >= 0 && counter < 4)){
      rect(thing.pos[1]*cellsize  +cellsize*(2+dirs[counter][1])/5, thing.pos[0]*cellsize + cellsize*(2+dirs[counter][0])/5 , cellsize/5, cellsize/5);
    }
    ctx.fillStyle = "#00FF00";
    rect(goalpost * cellsize,-2000, cellsize/5, 4000);
    ctx.fillStyle = "#000000";
    ctx.fillRect(0, 0, canvas.width, hpad/2);
    ctx.fillRect(0, 0, wpad/2, canvas.height);
    ctx.fillRect(0, canvas.height-hpad/2, canvas.width, hpad/2);
    ctx.fillRect(canvas.width-wpad/2, 0, wpad/2, canvas.height);
    if(showmessage5){
      messagetext = messages[4];
            
            showTempMessage();
            messagesaid[4] = true; 
            showmessage5 = false;
          }
      if(!messagesaid[5] && player.pos[1] > goalpost){
              messagetext = messages[5];
            
              showTempMessage();
              messagesaid[5] = true; 
              stopdrawing = true;
            }
    }
}

function cloneof(obj){
  return JSON.parse(JSON.stringify(obj));
}


function undo(){
  if(undostack.length == 1)return;
  undostack.pop();
  grid = cloneof(undostack[undostack.length-1].grid);
  connecteds = cloneof(undostack[undostack.length-1].connecteds);
  goalpost = undostack[undostack.length-1].goalpost;
  setstateto();
  
}

function reset(){
  grid = cloneof(undostack[0].grid);
  connecteds = cloneof(undostack[0].connecteds);
  goalpost = undostack[0].goalpost;
  undostack.push(cloneof(undostack[0]));

  setstateto();

}

function setstateto(){
  generation = false;
  stunlock = false;
  clearTimeout(timeoutId);
  Object.values(grid).map((object) => {
    if(object.type == "player") player = object;
    if(object.type == "thing") thing = object;
  })
  timeoutId = -1;
  counter = 0;
  draw();
}

function savestate(){
  undostack.push({grid: cloneof(grid), connecteds: cloneof(connecteds), goalpost: goalpost});
}

onkeydown = onKey;
generation = false;
keep = false;
savedstates = {};
function add(p1, p2){return [p1[0] + p2[0], p1[1] + p2[1], p1[2] + p2[2]]}
function equals(p1, p2){return p1[0] == p2[0] && p1[1] == p2[1] && p1[2] == p2[2]}
againtime = 100;
function onKey(e){
   if(stopdrawing) return;
  if(e.key >= '0' && e.key<='9'){
    if(keep){
      savedstates[e.key] = cloneof(undostack[undostack.length-1]);
      messagetext = "State kept in slot " + e.key + "!";
      showTempMessage();
    }
    if(load){
      if(!savedstates[e.key]){
        messagetext = "No state currently in slot " + e.key + " :(";
        showTempMessage();
      }else{
        grid = cloneof(savedstates[e.key].grid);
        connecteds = cloneof(savedstates[e.key].connecteds);
        goalpost = savedstates[e.key].goalpost;
        savestate();

        setstateto();
        messagetext = "State loaded from slot " + e.key + "!";
        showTempMessage();
      }
    }
  }
  keep = false;
  load = false;

  if(e.key == '['){
    if(againtime < 400) againtime *= 2;
  }
  if(e.key == ']'){
    if(againtime > 50) againtime /=2;
  }

  if(e.key == 'k'){
    keep = true;
  }
if(e.key == 'l'){
    load = true;
  }
  console.log(e);
  draw();
  
}

function win(){
  console.log("win")
}

dirs = [[-1, 0,0], [0, -1,0], [1, 0,0], [0, 1,0], [0,0,1], [0,0,-1]]

function makemove(obj, d){
  obj.willmove = false;
    
  delete grid[obj.pos]
  for(var i=0; i<=3; i++){
    if(equals(obj.pos,add(thing.pos, dirs[i]))){
      if(!connecteds[i]) playSound(23973703)
      connecteds[i] = true;
    }
  }
  obj.pos= add(obj.pos, d);
  if(obj.pos[2] >= 3) {
    return;
  }
  if(grid[obj.pos]) makemove(grid[obj.pos], d);
  grid[obj.pos] = obj;
}

function remove(obj){
  delete grid[obj.pos]
}

function trymove(obj, d, ply){

  if(!obj) return;

  if(obj.willmove) return true;
  if(obj.type == "thing" || obj.type == "floor") {
    moveok = false;
    return
  }
  if(grid[add(obj.pos, [0, 0, -1])] && grid[add(obj.pos, [0, 0, -1])].type == "player"){
    if(ply){
      moveok = false;
      return
    }
  }
  obj.willmove = true;
  if(grid[add(obj.pos, d)]) {
    trymove(grid[add(obj.pos, d)], d, ply);
  }
  dirs.map(dr => {
    if(grid[add(obj.pos, dr)] && obj.type == grid[add(obj.pos, dr)].type){
      trymove(grid[add(obj.pos, dr)],d, ply)
    }
  })

  

  
}

downsupported = false;
downclock = 0;
function setsupported(obj){
  if(!obj.willmove) return;
  if(obj.pos[2] >= 2) return;
  if(obj.pos[2] > 0){
    downsupported = true;
  }
  obj.willmove = false;
  dirs.map(dr => {
    if(grid[add(obj.pos, dr)] && obj.type == grid[add(obj.pos, dr)].type){
      setsupported(grid[add(obj.pos, dr)])
    }
  })
  if(grid[add(obj.pos, [0,0,-1])]){
      setsupported(grid[add(obj.pos, [0,0,-1])])
    }
}

stunlock = false;

function gravitystep(){
  Object.values(grid).map((object) => { object.willmove = true;});
  moveok = true;

  for(i=0; i<=10; i++) for(j=0; j<=10; j++) if(grid[[i,j,0]]) setsupported(grid[[i,j,0]])
  anyfell = false;
  makesound = false;
  Object.values(grid).map((object) => { 
    if(object.type == "floor") return;
    if(object.willmove){
      if(!object.gravitytimer) object.gravitytimer = 0;
      if(object.gravitytimer%8 == 0){
        makemove(object, [0,0,1]);
        makesound = true;
      }
       
      object.gravitytimer++;

      anyfell = true;
    }
  });
  if(makesound){
    playSound(46796706);
  }
  
}

function checkshouldagain(){
  

  Object.values(grid).map((object) => { object.willmove = true;});
  moveok = false;
  for(i=0; i<=10; i++) for(j=0; j<=10; j++)  if(grid[[i,j,0]]) setsupported(grid[[i,j,0]])
  Object.values(grid).map((object) => { 
    if(object.type == "floor") return;
    if(object.willmove){
      
      moveok = true;
    }
  });
  if(moveok) return true;
  


  for(i=0; i<=3; i++){
    if(generation && connecteds[i]){
      return true;
    }
  }
  generation = false;
  counter = 0;

  return false;
}



function again(){
  if(stopdrawing) return;
  stunlock = true;
  gravitystep();
  didtick = false;
  if(generation) {
    didtick = true;
    tick();
  }
  if(checkshouldagain()){
    timeoutId = setTimeout(again,againtime);
  }else if(movegoalpost.length > 0){
    if(!didtick){
    goalpost += movegoalpost[0];
    playSound(46796706);
    movegoalpost = movegoalpost.slice(1);
  }
    timeoutId =setTimeout(again,againtime);
  }else{
    timeoutId=-1;
    savestate();
    stunlock = false;
  }
  draw();
}
gravitytimer = 0;
moveok = false;
function initiatemove(obj, d, ply){
  if(!obj) return;
  if(ply && stunlock) return;

  Object.values(grid).map((object) => { object.willmove = false;});
  moveok = true;
  trymove(obj, d,ply);
  if(moveok){
    Object.values(grid).map((object) => { 
      if(object.willmove){
        makemove(object, d);
      }
    });

  }
  
  if(ply) {
    if(checkshouldagain()){
      gravitytimer = 0;
      timeoutId = setTimeout(again,againtime);
    }
    else{
      
    }
  }
  if(ply){
    
    savestate();
  }
  
  draw();

  
}

counter = 0;
number = 1;
function tick(){

  colors.thing = ["#664444", "#555544", "#446644", "#445555"][counter]
  if(number && connecteds[counter]){
    d = dirs[counter]
    
      initiatemove(grid[add(thing.pos, d)], d, false);
      if(!grid[add(thing.pos, d)]){
      newcol = {type: cols[counter], pos: add(thing.pos, d)};
      grid[newcol.pos] = newcol;
      connecteds[counter] = false;
      movegoalpost.push(1);
      playSound( 71682106);;
      /*messagetext = 'POWER: ON';
      showTempMessage() ;*/
          }
    
  }
  [0, 1, 2, 3].map(x => {

        if(!grid[add(dirs[x], thing.pos)] || cols[x] != grid[add(dirs[x], thing.pos)].type){
          connecteds[x] = true;
        }
      }
      )
  counter+=number;
  counter %= 4;
  draw();
  gravitystep();
  draw();


}



draw();

redraw = ()=>{
  if(!textMode) 
    draw();
  else{
    ctx.fillStyle = state.bgcolor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    for (var i = 0; i < titleWidth; i++){
      for (var j = 0; j < titleHeight; j++){
        var ch = titleImage[j].charAt(i);
        if (ch in textImages); {
          var sprite = textImages[ch];
          ctx.drawImage(sprite, xoffset + i * cellwidth, yoffset + j * cellheight);
        }
      }
    }
    return;
  }}
processInput = (dir) => {
   if(stopdrawing) return;
  ULBS()
   keep = false;
  load = false;
  if (dir >= 0 && dir <= 3) {
    if(undostack.length >= 30 && !xpressed && !messagesaid[0]){
      messagetext = messages[0];
      showTempMessage();
      messagesaid[0] = true; 
    }
    if(undostack.length >= 300 && !messagesaid[1]){
      messagetext = messages[1];
      showTempMessage();
      messagesaid[1] = true; 
    }
 
    if(undostack.length >= 100 && !messagesaid[2]){
      messagetext = messages[2];
      showTempMessage();
      messagesaid[2] = true; 
    }
    if(goalpost > 10000 && !messagesaid[6]){
messagetext = messages[6];
      showTempMessage();
      messagesaid[6] = true; 
    }
    initiatemove(player, dirs[dir], 1);
   
  }
  if(dir == 4){
   
    if(!stunlock && timeoutId == -1) {
      generation = true;
      xpressed = true;
      again(); 
    }
  }
  draw()
   
}

DoRestart = reset
DoUndo = undo
</script>


<div style = "z-index: 2; background: transparent; position: absolute; top: 0.5em; right: 1em;">
  <img alt="mute" id="muteButton" width=32px height=32px onClick="muteAudio()" style="display:none"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABl0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC4xOdTWsmQAAAIGSURBVFhH3ZchcsJAGIURiApEBbIH6BEqOQASWYHoESoQFcwgOAaiEsEBKip6BERlBQJRwQEqtu/tvj+TLMnAJpntTL+ZP/De7p/9k102YUCcc0tEbpbx4MHIAMcKQ2LM4ktmOCYH9gXIawXzQasLYGKnAphryErC53VJLiPvhNgjtog54tZ3bgDt7QpgTkyD/42Y+aQa2CG5APYvMdGnFTBC3COeEG8IY4M4uxtsSCqAfQ1ZhSdZATangdNCvhCVImheVQC6FFdKZHtkeQ8fB8QOsUCM5N0hPhBkQ8+gEQ5BXLUb+swSsu0cZXjFE/kswu7ElB6hCAeJS/isCDXZOcaIKeKdHvhBPKiN00F4l+zu1BaQtKkop1Ic5BCx8g3OfSJu5Fthj9LnBfB7Ckqzc/Dq1oihtA34LP0SpHuV7r0AYyXN6SC7SO+ley9gFpQ7SHNNkFifpP9fAcZaOvsUNC3ChbQtwq30eQGg88+QwLKNjRuS/e6toLl0bQGNsF+MmuwcdRuR7Ya2EfEJ6Z8JFOEQRK6tuHg8U4TDBdClr4eRn3uDRjhcCfsasgpPsgLs8uP4iBiryUMzqQDC/iXiFxJbA1zttg4IX9EqgxM2JBdAmBPT4Pf/SmYwr4y8PC+lBnMNWUn4vLbJBvNBtz8m4E//mtkGlK0IjhWG1Jj8EnRWMPhg8AvjeqPLyfe3igAAAABJRU5ErkJggg==" />
  <img alt="unmute" id="unMuteButton" width=32px height=32px onClick="unMuteAudio()" style="display:none" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTnU1rJkAAABqElEQVRYR72XW3LDMAwDc7QerTdPRWjBoW1aedXZGUYUAIlqP9LpLbjf77+jvs3vfvgUvkDMmiPHzGxg9HTXEjNjsB6A0Nar+MxYg+UPFoH5ccLCauE+3Wmqvke+Pk5YWAl3sJuXGiSx3wfSOsMsrKRm4i6DJJAEktB+L1YW1oG4xyAJJIGUSOsMs7A2xB0GSSAJpA3Sz8xgYYnh/8R5g+ZKFG6Q9yAQ9dS3JEcEkkBqkb8K2X8EcYEkkE5RxkH6rkz7VT10uu3wwcbrcOipB+hEg62ZmlR9hbL1wEkJndgRMpVgif1+j3yH6LsSOtGALZAE0rUPwBJICfJ1D0A2ylamfDxXke8QfVfCGdak6pXpNkZBvkP0XeUl3hvkFiKfP8CwT5BPIfavD0iQBNJhEPJnDzCjr6Q31sMfI4P0/gPM6BP20ivTnSClxrZFvkP0WQ4YCQuImfzNYLfId4i+VqL0ExDfgNUi3yF6V6LkC3AsQW6R7xB9rZeHmzhrkFrkO0R/qHcZZ4Plv3sROARHv1mvImbG4GxixbucmDVHMjOauf8qY/jt9gdOODPsYZA1BAAAAABJRU5ErkJggg==" />
</div>

</body>
</html>
